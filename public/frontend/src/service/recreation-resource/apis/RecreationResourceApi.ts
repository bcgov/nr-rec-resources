/* tslint:disable */
/* eslint-disable */
/**
 * Recreation Sites and Trails BC API
 * RST API documentation
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import type {
  AlphabeticalRecreationResourceDto,
  PaginatedRecreationResourceDto,
  RecResourcesIdsDto,
  RecreationResourceDetailDto,
  RecreationResourceSearchWithGeometryDto,
  RecreationSuggestionDto,
  SiteOperatorDto,
} from '../models/index';
import {
  AlphabeticalRecreationResourceDtoFromJSON,
  AlphabeticalRecreationResourceDtoToJSON,
  PaginatedRecreationResourceDtoFromJSON,
  PaginatedRecreationResourceDtoToJSON,
  RecResourcesIdsDtoFromJSON,
  RecResourcesIdsDtoToJSON,
  RecreationResourceDetailDtoFromJSON,
  RecreationResourceDetailDtoToJSON,
  RecreationResourceSearchWithGeometryDtoFromJSON,
  RecreationResourceSearchWithGeometryDtoToJSON,
  RecreationSuggestionDtoFromJSON,
  RecreationSuggestionDtoToJSON,
  SiteOperatorDtoFromJSON,
  SiteOperatorDtoToJSON,
} from '../models/index';

export interface GetRecreationResourceByIdRequest {
  id: string;
  imageSizeCodes?: Array<string>;
}

export interface GetRecreationResourcesAlphabeticallyRequest {
  letter: string;
  type?: string;
}

export interface GetRecreationSuggestionsRequest {
  query: string;
}

export interface GetResourcesWithGeometryRequest {
  recResourcesIdsDto: RecResourcesIdsDto;
}

export interface GetSiteOperatorByIdRequest {
  id: string;
}

export interface SearchRecreationResourcesRequest {
  filter?: string;
  limit?: number;
  page?: number;
  activities?: string;
  type?: string;
  district?: string;
  access?: string;
  facilities?: string;
  status?: string;
  fees?: string;
  lat?: number;
  lon?: number;
}

export interface SearchRecreationResourcesWithGeometryRequest {
  filter?: string;
  limit?: number;
  page?: number;
  activities?: string;
  type?: string;
  district?: string;
  access?: string;
  facilities?: string;
  status?: string;
  fees?: string;
  lat?: number;
  lon?: number;
}

/**
 *
 */
export class RecreationResourceApi extends runtime.BaseAPI {
  /**
   * Find recreation resource by ID
   */
  async getRecreationResourceByIdRaw(
    requestParameters: GetRecreationResourceByIdRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<RecreationResourceDetailDto>> {
    if (requestParameters['id'] == null) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter "id" was null or undefined when calling getRecreationResourceById().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters['imageSizeCodes'] != null) {
      queryParameters['imageSizeCodes'] = requestParameters['imageSizeCodes'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/api/v1/recreation-resource/{id}`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(requestParameters['id'])),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      RecreationResourceDetailDtoFromJSON(jsonValue),
    );
  }

  /**
   * Find recreation resource by ID
   */
  async getRecreationResourceById(
    requestParameters: GetRecreationResourceByIdRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<RecreationResourceDetailDto> {
    const response = await this.getRecreationResourceByIdRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Returns recreation resources in alphabetical order. Use letter parameter to filter by starting letter (A-Z) or # for numerical names.
   * Get recreation resources alphabetically
   */
  async getRecreationResourcesAlphabeticallyRaw(
    requestParameters: GetRecreationResourcesAlphabeticallyRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<AlphabeticalRecreationResourceDto>>> {
    if (requestParameters['letter'] == null) {
      throw new runtime.RequiredError(
        'letter',
        'Required parameter "letter" was null or undefined when calling getRecreationResourcesAlphabetically().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters['letter'] != null) {
      queryParameters['letter'] = requestParameters['letter'];
    }

    if (requestParameters['type'] != null) {
      queryParameters['type'] = requestParameters['type'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/api/v1/recreation-resource/alphabetical`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(AlphabeticalRecreationResourceDtoFromJSON),
    );
  }

  /**
   * Returns recreation resources in alphabetical order. Use letter parameter to filter by starting letter (A-Z) or # for numerical names.
   * Get recreation resources alphabetically
   */
  async getRecreationResourcesAlphabetically(
    requestParameters: GetRecreationResourcesAlphabeticallyRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<AlphabeticalRecreationResourceDto>> {
    const response = await this.getRecreationResourcesAlphabeticallyRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Returns a list of suggested recreation resources based on a partial search term.
   * Get search suggestions
   */
  async getRecreationSuggestionsRaw(
    requestParameters: GetRecreationSuggestionsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<RecreationSuggestionDto>>> {
    if (requestParameters['query'] == null) {
      throw new runtime.RequiredError(
        'query',
        'Required parameter "query" was null or undefined when calling getRecreationSuggestions().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters['query'] != null) {
      queryParameters['query'] = requestParameters['query'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/api/v1/recreation-resource/suggestions`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(RecreationSuggestionDtoFromJSON),
    );
  }

  /**
   * Returns a list of suggested recreation resources based on a partial search term.
   * Get search suggestions
   */
  async getRecreationSuggestions(
    requestParameters: GetRecreationSuggestionsRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<RecreationSuggestionDto>> {
    const response = await this.getRecreationSuggestionsRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   *        Returns a non paginated list of recreation resources and related data with geometry appended.
   * Get a list recreation resources with geometry. This uses the POST method to overcome the querystring limit.
   */
  async getResourcesWithGeometryRaw(
    requestParameters: GetResourcesWithGeometryRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<RecreationResourceDetailDto>>> {
    if (requestParameters['recResourcesIdsDto'] == null) {
      throw new runtime.RequiredError(
        'recResourcesIdsDto',
        'Required parameter "recResourcesIdsDto" was null or undefined when calling getResourcesWithGeometry().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    const response = await this.request(
      {
        path: `/api/v1/recreation-resource/geometry`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: RecResourcesIdsDtoToJSON(requestParameters['recResourcesIdsDto']),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(RecreationResourceDetailDtoFromJSON),
    );
  }

  /**
   *        Returns a non paginated list of recreation resources and related data with geometry appended.
   * Get a list recreation resources with geometry. This uses the POST method to overcome the querystring limit.
   */
  async getResourcesWithGeometry(
    requestParameters: GetResourcesWithGeometryRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<RecreationResourceDetailDto>> {
    const response = await this.getResourcesWithGeometryRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Find site operator by resource ID
   */
  async getSiteOperatorByIdRaw(
    requestParameters: GetSiteOperatorByIdRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<SiteOperatorDto>> {
    if (requestParameters['id'] == null) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter "id" was null or undefined when calling getSiteOperatorById().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/api/v1/recreation-resource/{id}/site-operator`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(requestParameters['id'])),
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      SiteOperatorDtoFromJSON(jsonValue),
    );
  }

  /**
   * Find site operator by resource ID
   */
  async getSiteOperatorById(
    requestParameters: GetSiteOperatorByIdRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<SiteOperatorDto> {
    const response = await this.getSiteOperatorByIdRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   *        Returns a paginated list of recreation resources and related data (result counts, filters, extent).       The unpaginated summary data (counts, filters, extent) is based on the first 5000 matching records only, due       to internal limits for performance reasons. This limit does not affect the main paginated resource list.
   * Search recreation resources
   */
  async searchRecreationResourcesRaw(
    requestParameters: SearchRecreationResourcesRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<PaginatedRecreationResourceDto>> {
    const queryParameters: any = {};

    if (requestParameters['filter'] != null) {
      queryParameters['filter'] = requestParameters['filter'];
    }

    if (requestParameters['limit'] != null) {
      queryParameters['limit'] = requestParameters['limit'];
    }

    if (requestParameters['page'] != null) {
      queryParameters['page'] = requestParameters['page'];
    }

    if (requestParameters['activities'] != null) {
      queryParameters['activities'] = requestParameters['activities'];
    }

    if (requestParameters['type'] != null) {
      queryParameters['type'] = requestParameters['type'];
    }

    if (requestParameters['district'] != null) {
      queryParameters['district'] = requestParameters['district'];
    }

    if (requestParameters['access'] != null) {
      queryParameters['access'] = requestParameters['access'];
    }

    if (requestParameters['facilities'] != null) {
      queryParameters['facilities'] = requestParameters['facilities'];
    }

    if (requestParameters['status'] != null) {
      queryParameters['status'] = requestParameters['status'];
    }

    if (requestParameters['fees'] != null) {
      queryParameters['fees'] = requestParameters['fees'];
    }

    if (requestParameters['lat'] != null) {
      queryParameters['lat'] = requestParameters['lat'];
    }

    if (requestParameters['lon'] != null) {
      queryParameters['lon'] = requestParameters['lon'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/api/v1/recreation-resource/search`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      PaginatedRecreationResourceDtoFromJSON(jsonValue),
    );
  }

  /**
   *        Returns a paginated list of recreation resources and related data (result counts, filters, extent).       The unpaginated summary data (counts, filters, extent) is based on the first 5000 matching records only, due       to internal limits for performance reasons. This limit does not affect the main paginated resource list.
   * Search recreation resources
   */
  async searchRecreationResources(
    requestParameters: SearchRecreationResourcesRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<PaginatedRecreationResourceDto> {
    const response = await this.searchRecreationResourcesRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   *        Returns a non paginated list of recreation resources and related data with geometry appended.       The unpaginated summary data (counts, filters, extent) is based on the first 5000 matching records only, due       to internal limits for performance reasons. This limit does not affect the main paginated resource list.
   * Search recreation resources with geometry
   */
  async searchRecreationResourcesWithGeometryRaw(
    requestParameters: SearchRecreationResourcesWithGeometryRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<
    runtime.ApiResponse<Array<RecreationResourceSearchWithGeometryDto>>
  > {
    const queryParameters: any = {};

    if (requestParameters['filter'] != null) {
      queryParameters['filter'] = requestParameters['filter'];
    }

    if (requestParameters['limit'] != null) {
      queryParameters['limit'] = requestParameters['limit'];
    }

    if (requestParameters['page'] != null) {
      queryParameters['page'] = requestParameters['page'];
    }

    if (requestParameters['activities'] != null) {
      queryParameters['activities'] = requestParameters['activities'];
    }

    if (requestParameters['type'] != null) {
      queryParameters['type'] = requestParameters['type'];
    }

    if (requestParameters['district'] != null) {
      queryParameters['district'] = requestParameters['district'];
    }

    if (requestParameters['access'] != null) {
      queryParameters['access'] = requestParameters['access'];
    }

    if (requestParameters['facilities'] != null) {
      queryParameters['facilities'] = requestParameters['facilities'];
    }

    if (requestParameters['status'] != null) {
      queryParameters['status'] = requestParameters['status'];
    }

    if (requestParameters['fees'] != null) {
      queryParameters['fees'] = requestParameters['fees'];
    }

    if (requestParameters['lat'] != null) {
      queryParameters['lat'] = requestParameters['lat'];
    }

    if (requestParameters['lon'] != null) {
      queryParameters['lon'] = requestParameters['lon'];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/api/v1/recreation-resource/geometry`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(RecreationResourceSearchWithGeometryDtoFromJSON),
    );
  }

  /**
   *        Returns a non paginated list of recreation resources and related data with geometry appended.       The unpaginated summary data (counts, filters, extent) is based on the first 5000 matching records only, due       to internal limits for performance reasons. This limit does not affect the main paginated resource list.
   * Search recreation resources with geometry
   */
  async searchRecreationResourcesWithGeometry(
    requestParameters: SearchRecreationResourcesWithGeometryRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<RecreationResourceSearchWithGeometryDto>> {
    const response = await this.searchRecreationResourcesWithGeometryRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }
}
